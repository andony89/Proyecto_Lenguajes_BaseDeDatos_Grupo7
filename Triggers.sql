/*1.*/
ALTER TABLE Productos
ADD FechaModificacion DATE;

CREATE OR REPLACE TRIGGER trg_actualizar_fecha_modificacion_producto
    BEFORE UPDATE
    ON Productos
    FOR EACH ROW
BEGIN
    :NEW.FechaModificacion := SYSDATE;
END;

/*2.*/ 
CREATE TABLE LogCambiosInventario (
    LogID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    InventarioID NUMBER NOT NULL,
    ProductoID NUMBER NOT NULL,
    Cantidad NUMBER NOT NULL,
    TipoTransaccion VARCHAR2(10) NOT NULL,
    Fecha DATE NOT NULL,
    Usuario VARCHAR2(50) NOT NULL
);

CREATE OR REPLACE TRIGGER trg_log_cambios_inventario
    AFTER
    UPDATE OR DELETE
    ON Inventario
    FOR EACH ROW
DECLARE
    l_transaction VARCHAR2(10);
BEGIN
    -- Determinar el tipo de transacción
    l_transaction := CASE
                        WHEN UPDATING THEN 'UPDATE'
                        WHEN DELETING THEN 'DELETE'
                        END;
END;
/*3.*/

CREATE OR REPLACE TRIGGER trg_validar_cantidad_producto
    BEFORE UPDATE
    ON Inventario
    FOR EACH ROW
BEGIN
    IF :NEW.Cantidad < 0 THEN
        RAISE_APPLICATION_ERROR(-20001, 'La cantidad de un producto no puede ser menor que cero.');
    END IF;
END;

/*4.*/
CREATE OR REPLACE TRIGGER trg_actualizar_stock_venta
    AFTER INSERT
    ON Factura
    FOR EACH ROW
BEGIN
    UPDATE Productos
    SET Slock = Slock - :NEW.Cantidad
    WHERE ProductoID = :NEW.ProductoID;
END;


/*5.*/

CREATE TABLE LogEliminacionProveedores (
    LogID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ProveedorID NUMBER NOT NULL,
    Nombre VARCHAR2(100) NOT NULL,
    FechaEliminacion DATE NOT NULL,
    Usuario VARCHAR2(50) NOT NULL
);

CREATE OR REPLACE TRIGGER trg_log_eliminacion_proveedor
    AFTER DELETE
    ON Proveedores
    FOR EACH ROW
BEGIN
    INSERT INTO LogEliminacionProveedores (ProveedorID, Nombre, FechaEliminacion, Usuario)
    VALUES(:OLD.ProveedorID, :OLD.Nombre, SYSDATE, USER);
END;